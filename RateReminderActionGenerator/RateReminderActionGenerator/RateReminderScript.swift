//
//  RateReminderScript.swift
//  NStackSDK
//
//  Created by Andrew Lloyd on 12/01/2022.
//  Copyright Â© 2022 Nodes ApS. All rights reserved.
//

import Foundation
import Combine

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@main
enum MyScript {
    fileprivate static let plistAppIDKey  = "APPLICATION_ID"
    fileprivate static let plistAppKeyKey = "REST_API_KEY"
    
    static func main() {
        var lastKey = ""
        var parsedArguments = [String: [String]]()
        for arg in CommandLine.arguments {
            if arg.hasPrefix("-") {
                parsedArguments[arg] = []
                lastKey = arg
            } else {
                parsedArguments[lastKey]?.append(arg)
            }
        }
        
        guard let outputPath = parsedArguments["-output"]?.first,
              let plistPath = parsedArguments["-plist"]?.first,
              let keys = try? keysFromConfigurationFile(plistPath: plistPath)
        else {
            print("output or plist input missing")
            exit(1)
        }
        
        var cancelHandler: AnyCancellable?
        let group = DispatchGroup()
        
        var headers: [String: String] {
            return [
                "X-Application-id": keys.appId,
                "X-Rest-Api-Key": keys.restApiKey
            ]
        }
        
        var request = URLRequest(url: URL(string: "https://nstack.io/api/v2/notify/rate_reminder_v2/actions")!)
        request.httpMethod = "GET"
        request.allHTTPHeaderFields = headers
        
        let publisher = URLSession.shared.dataTaskPublisher(for: request)
        let configPublisher = publisher
            .map(\.data)
            .decode(type: ActionsConfig.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
        
        group.enter()
        cancelHandler = configPublisher.sink { completion in
            switch completion {
            case .failure(let error):
                print("\(error)")
                group.leave()
                exit(1)
            case .finished:
                break
            }
        } receiveValue: { value in
            print("RECEIVED ACTIONS: \(value.data.count)")
            try! writeActionsToFile(actions: value.data, outputPath: outputPath)
        }
        group.wait()
        cancelHandler?.cancel()
    }
    
    private static func writeActionsToFile(actions: [String], outputPath: String) throws {
        let codeString = generateActionEnumStringFromArray(actions: actions)
        
        try! codeString.write(toFile: "\(outputPath)/RateReminderActions.swift",
                              atomically: true,
                              encoding: String.Encoding.utf8)
        
        print("RATE REMINDER ACTIONS WRITTEN TO FILE")
        exit(0)
    }
    
    private static func generateActionEnumStringFromArray( actions: [String]) -> String {
        var indent = Indentation(level: 0)
        var result = "// File generated by NStack Rate Reminder Action Generator\n\n"
        result += "import Foundation\n"
        result += "import NStackSDK\n\n"
        result += "public enum RateReminderAction: String {\n"
        
        indent = indent.nextLevel()
        
        for action in actions {
            result += indent.string()
            result += "case \(action)\n"
        }
        
        indent = indent.previousLevel()
        result += indent.string() + "}\n\n"
        
        result += "extension RateReminderAction: RateReminderActionProtocol {\n"
        
        indent = indent.nextLevel()
        result += indent.string()
        result += "public var actionString: String {\n"
        
        indent = indent.nextLevel()
        result += indent.string()
        result += "self.rawValue\n"
        
        indent = indent.previousLevel()
        result += indent.string()
        result += "}\n"
        
        indent = indent.previousLevel()
        result += indent.string() + "}\n\n"
        
        return result
    }
    
    private static func keysFromConfigurationFile(plistPath: String) throws -> KeysConfig {
        let data = try Data(contentsOf: Foundation.URL(fileURLWithPath: plistPath), options: NSData.ReadingOptions(rawValue: 0))
        let plist = try PropertyListSerialization.propertyList(from: data, options: PropertyListSerialization.MutabilityOptions(), format: nil)

        guard let dictionary = plist as? [String: AnyObject] else {
            print("NStack Plist misssing")
            exit(1)
        }

        
        guard let identifier = dictionary[plistAppIDKey] as? String, !identifier.isEmpty,
              let key = dictionary[plistAppKeyKey] as? String, !key.isEmpty else {
                  print("NStack keys misssing")
                  exit(1)
              }
        
        return KeysConfig(appId: identifier, restApiKey: key)
    }
}

// MARK: - Actions Model
struct ActionsConfig: Codable {
    let data: [String]
}

struct KeysConfig: Codable {
    let appId: String
    let restApiKey: String
}

// MARK: - Formatting helpers
public struct Indentation {
    public static let defaultString = String(repeating: " ", count: 4)
    
    public let level: Int
    public let customString: String?
    
    public init(level: Int) {
        self.level = level
        self.customString = nil
    }
    
    public init(level: Int, customString: String?) {
        self.level = level
        self.customString = customString
    }
}

public extension Indentation {
    func string() -> String {
        var string = ""
        let indent = (customString ?? Indentation.defaultString)
        
        for _ in 0..<level {
            string += indent
        }
        
        return string
    }
}

public extension Indentation {
    func nextLevel() -> Indentation {
        return Indentation(level: level + 1, customString: customString)
    }
    
    func previousLevel() -> Indentation {
        return Indentation(level: level > 0 ? level - 1 : 0, customString: customString)
    }
}
